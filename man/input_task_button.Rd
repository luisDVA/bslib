% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/buttons.R
\name{input_task_button}
\alias{input_task_button}
\alias{icon_spinner}
\alias{update_task_button}
\alias{set_task_button_manual_reset}
\title{Button for launching longer-running operations}
\usage{
input_task_button(
  id,
  label,
  icon = NULL,
  busy_label = "Processing...",
  busy_icon = icon_spinner(),
  type = "primary",
  ...
)

icon_spinner()

update_task_button(id, busy = NULL, session = get_current_session())

set_task_button_manual_reset(session, id, manual = TRUE)
}
\arguments{
\item{id}{The \code{input} slot that will be used to access the value.}

\item{label}{The label of the button while it is in ready (clickable) state;
usually a string.}

\item{icon}{An optional icon to display next to the label while the button is
in ready state. See \code{\link[fontawesome:fa_i]{fontawesome::fa_i()}}.}

\item{busy_label}{The label of the button while it is busy.}

\item{busy_icon}{The icon to display while the button is busy. By default, a
spinning "chasing arrows" icon is used.}

\item{type}{One of the Bootstrap theme colors (\code{"primary"}, \code{"default"},
\code{"secondary"}, \code{"success"}, \code{"danger"}, \code{"warning"}, \code{"info"}, \code{"light"},
\code{"dark"}), or \code{NULL} to leave off the Bootstrap-specific button CSS classes
altogether.}

\item{...}{Named arguments become attributes to include on the \verb{<button>}
element.}

\item{busy}{If \code{TRUE}, put the button into busy/disabled state. If \code{FALSE},
put the button into ready/enabled state.}

\item{session}{The \code{session} object; using the default is recommended.}

\item{manual}{If \code{TRUE}, prevent automatic resetting of the task button when
reactive flush is complete.}
}
\description{
\code{input_task_button} is a button that can be used in conjuction with
\code{\link[shiny:bindEvent]{shiny::bindEvent()}} (or the older \code{\link[shiny:observeEvent]{shiny::eventReactive()}} and
\code{\link[shiny:observeEvent]{shiny::observeEvent()}} functions) to trigger actions or recomputation.

It is similar to \code{\link[shiny:actionButton]{shiny::actionButton()}}, except it prevents the user from
clicking when its operation is already in progress.

Upon click, it automatically displays a customizable progress message and
disables itself; and after the server has dealt with whatever reactivity is
triggered from the click, the button automatically reverts to its original
appearance and re-enables itself.
}
\section{Manual button reset}{

In some advanced use cases, it may be necessary to keep a task button in its
busy state even after the normal reactive processing has completed. The
\code{set_task_button_manual_reset} function can be called from the server to opt
out of the automatic reset behavior for a specific task button. After doing
so, the button can only be re-enabled by calling \code{update_task_button(id, busy = FALSE)}.

Note that, as a general rule, Shiny's \code{update} family of functions do not
take effect at the instant that they are called, but are held until the end
of the current flush cycle. So if you have many different reactive
calculations and outputs, you don't have to be too careful about when you
call \code{update_task_button(id, busy = FALSE)}, as the button on the client will
not actually re-enable until the same moment that all of the updated outputs
simultaneously sent to the client.
}

\section{Server value}{

An integer of class \code{"shinyActionButtonValue"}. This class differs from
ordinary integers in that a value of 0 is considered "falsy".
This implies two things:
\itemize{
\item Event handlers (e.g., \code{\link[shiny:observeEvent]{shiny::observeEvent()}}, \code{\link[shiny:observeEvent]{shiny::eventReactive()}}) won't execute on initial load.
\item Input validation (e.g., \code{\link[shiny:req]{shiny::req()}}, \code{\link[shiny:validate]{shiny::need()}}) will fail on initial load.
}
}

\examples{
if (interactive()) {
  library(shiny)
  library(bslib)

  ui <- page_sidebar(
    sidebar = sidebar(open = "always",
      input_task_button("resample", "Resample"),
    ),
    verbatimTextOutput("summary")
  )

  server <- function(input, output, session) {
    sample <- eventReactive(input$resample, ignoreNULL=FALSE, {
      Sys.sleep(2)  # Make this artificially slow
      rnorm(100)
    })

    output$summary <- renderPrint({
      summary(sample())
    })
  }

  shinyApp(ui, server)
}

}
